#include <stdio.h>
#include<stdlib.h>
int count=0;
struct node//struct declaration
{
    char data;
    struct node *next;
}*head;
void create()//creation of node function
{   int num;
    struct node *temp,*newnode;
      head=0;//before creation of node head becomes null
      int choice;
      while(choice)//to know whether user want to create another node or not
      {
    newnode=(struct node *)malloc(sizeof(struct node));//dynamic memory allocation for node
    printf("enter the data to create");
    scanf("%s",&newnode->data);//enter data part of node
    newnode->next=0;//for starting node address part becomes null
    if(head==0)//if head is null
    {
        head=temp=newnode;//newnode addr is assigned to head which is created 
    }
    else//otherwiseat 
    {
        temp->next=newnode;//starting node temp is created to store starting addr (this starting part addrs may contain new node addr)
        temp=newnode;//now temp is updated to new node addr
    }
    count++;//to know the no.of nodes
    printf("do u want to create anothe node?");//choice to create another node
    scanf("%d",&choice);
      }
      newnode->next=head;
}

void display()//display function
{
    struct node *temp;
    temp=(char *)temp;
    temp=head;//head addr is assigned to temp
    while(temp->next!=head)//condition to check if temp is not null(it continues upto last node)
    {
        printf("%c",temp->data);//temp date is displayed
        temp=temp->next;//temp value is increased to next addrs
    }
    printf("%c",temp->data);
    printf("\nno. of nodes is %d",count);//to know the count
   
}
void beg_insert()//beg insertion
{
    struct node *temp,*newnode;
   newnode=(struct node *)malloc(sizeof(struct node));
    printf("enter the data to insert\n");
    scanf("%s",&newnode->data);
    while(temp->next!=head)//upto last node temp is going to change(when condition fails it reached to last null)
    {
        temp=temp->next;//temp is updated with next node addrs upto last null
    }
    newnode->next=head;//head contains first node addr so that addr is assigned to newnode next to create link between newnode and already created node
    head=newnode;
    temp->next=head;//newnode addr assigned to head to become 1st node
    count++;
}
 void end_insert()//ending insertion
 {
     struct node *temp,*newnode;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf("enter the data to insert\n");
    scanf("%s",&newnode->data);
    newnode->next=head;//for newly created node addr becomes null
    temp=head;//head is assigned to null
    while(temp->next!=head)//upto last node temp is going to change(when condition fails it reached to last null)
    {
        temp=temp->next;//temp is updated with next node addrs upto last null
    }
    temp->next=newnode;//when reaches to last null condition fails(newnode addr is assigned to before node addr to create connection)
    count++;
 }
 void middle_insert()//middle insertion fun
 { 
     struct node *temp,*newnode;
     int pos,i=1;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf("enter the pos\n");
    scanf("%d",&pos);
    if(pos>count)
    {
        printf("invalid position\n");
    }
    else 
    {
    printf("enter the data to insert\n");
    scanf("%s",&newnode->data);
    temp=head;
    while(i<pos-1)//upto given position link is traverse
    {
        temp=temp->next;//temp is updated with next node addrs
        i++;//i value increases
    }
    newnode->next=temp->next;//to provide the connection temp next is assigned to newnodenext
    temp->next=newnode;//new node is assigned to temp to provide connection
    }
    count++;
 }
 void beg_delete()//beg deletion fun
 {
     struct node *temp,*d;
     temp=head;
     if(head==NULL)
     {
         printf("empty linkedlist\n");
     }
     //temp=head;
     else
     {
         temp=head;
         while(temp->next!=head)//upto last node temp is going to change(when condition fails it reached to last null)
        {
             temp=temp->next;//temp is updated with next node addrs upto last null
        }
    d=head;
     head=head->next;//to delete first node head is updated with headnext value
     temp->next=head;
     d->next=NULL;
     //free(temp);//emp becomes free
     }
     //d->next=NULL;
 }
 void end_delete()//end del fun
 {
     struct node *temp,*prevnode;
     temp=head;
     while(temp->next!=head)//upto last node ,link traverse
     {
         prevnode=temp;//temp addr is assigned to previous node
         temp=temp->next;//temp(next) is assigned to temp
     }
     if(temp==head)
     {
         head=0;
     }
      else
      {
          prevnode->next=head;//last node becomes nulli.e., prevnode
      }
      free(temp);
 }
 void middle_delete()//mid deletion fun
 {
     struct node *nextnode,*temp;
     int pos,i=1;
     printf("enter the pos\n");
     scanf("%d", &pos);
     temp=head;
     while(i<pos-1)//upto pos it traverse
     {
         temp=temp->next;//temp is updated with next node addr
         i++;
     }
     nextnode=temp->next;//to disable the connection tempnext is assigned to nextnode 
     temp->next=nextnode->next;//nextnode addrs is assigned to temp next
     free(nextnode);
     count--;
 }
int main()
{
    int choice;
    printf("\n\t LINKED LIST OPERATIONS ");
     printf("\n\t 1.CREATE \n\t 2.DISPLAY \n\t 3.BEG_INSERT\n\t 4.END_INSERT\n\t 5.MID_INSERT\n\t 6.BEG_DELETE\n\t 7.END_DELETE 8.MIDDLE_DELETE 9.EXIT");
      do
    {
        printf("\n Enter the Choice:");
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:
            {
                create();
                break;
            }
            case 2:
            {
                display();
                break;
            }
            case 3:
            {
                beg_insert();
                break;
            }
            
            case 4:
            {
                end_insert();
                break;
            }
            case 5:
            {
                middle_insert();
                break;
                
            }
            case 6:
            {
                beg_delete();
                break;
            }
            case 7:
            {
                end_delete();
                break;
            }
            case 8:
            {
                middle_delete();
                break;
            }
            case 9:
            {
                printf("exit point");
                break;
            }
             default:
            {
                printf ("\n\t Please Enter a Valid Choice");
            }
            }
            }

            while(choice!=9);
    return 0;
}


OUTPUT:

LINKED LIST OPERATIONS 
	 1.CREATE 
	 2.DISPLAY 
	 3.BEG_INSERT
	 4.END_INSERT
	 5.MID_INSERT
	 6.BEG_DELETE
	 7.END_DELETE 8.MIDDLE_DELETE 9.EXIT
 Enter the Choice:1
 enter the data to created
 do u want to create anothe node?1
 enter the data to createg
 do u want to create anothe node?0
 Enter the Choice:2
 dg
no. of nodes is 2
 Enter the Choice:3
 enter the data to insert
j
Enter the Choice:4
enter the data to insert
u
Enter the Choice:5
enter the pos
2
enter the data to insert
n
Enter the Choice:2
jndgu
no. of nodes is 5
 Enter the Choice:6
 Enter the Choice:2
 ndgu
 no.on nodes is 4
Footer
